---
title: "Bayesian Networks in Formula One Race Strategy"
subtitle: "Round 1: Bahrain GP 2023"
author: "Natalia Kortals"
output: html_document
date: '2024-10-23'
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(data.table)
library(GGally)
```

## EDA

Firstly, we load the data saved into .csv file, acquired using f1dataR package. https://CRAN.R-project.org/package=f1dataR

```{r load data}
BAH = data.frame(read.csv("data/bahrain2023.csv", header =TRUE))
head(BAH)
```

```{r}
summary(BAH)
```


team vs position boxplot



Next, we plot the variables to understand the dataset: 

```{r plot pitstop vs laptime}
ggplot(data=subset(BAH, !is.na(pitstop_duration)), aes(x=pitstop_duration, y = lap_time)) +
  geom_point()  + geom_smooth(method=lm) +
  labs(x = "Pitstop Duration", y = "Lap Time", title = "Pitstop Duration vs Lap Times at Bahrain GP 2023") +
  theme(plot.title = element_text(hjust=0.5))
```


```{r plot team vs pitstop_duration}
# ggplot() + geom_boxplot(aes(x = BAH$team, y = BAH$pitstop_duration))

ggplot() + geom_boxplot(aes(x = BAH$team, y = BAH$pitstop_duration))+
  labs(x = "Team", y = "Pitstop Duration", title = "Box Plot of Pitstop Duration per Team (Bahrain 2023)") +
  theme_minimal() + theme(axis.text.x = element_text(angle = 45, hjust=1)) +
  theme(plot.title = element_text(hjust = 0.5))
```

```{r plot position vs laptime}
ggplot(data=BAH, aes(x=position, y = lap_time)) +
  geom_point()  + #geom_smooth(method=lm) +
  labs(x = "Position", y = "Lap Time", title = "Position vs Lap Times at Bahrain GP 2023") +
  theme(plot.title = element_text(hjust=0.5))
```

```{r plot team vs position}

ggplot() + geom_boxplot(aes(x = BAH$team, y = BAH$position))+
  labs(x = "Team", y = "Position", title = "Box Plot of Position per Team (Bahrain 2023)") +
  theme_minimal() + theme(axis.text.x = element_text(angle = 45, hjust=1)) +
  theme(plot.title = element_text(hjust = 0.5))
```
From the plot above, we can for example see that Red Bull Racing drivers stayed in the front the entire time, while Alpine drivers spanned positions between 16 and 10 - either because their drivers were far apart, or climbed or lost many positions throughout the event.

```{r}
BAH %>%
  ggplot( aes(x=lap_time, colour = tyre, fill = tyre)) +
    geom_density(alpha = 0.4)
```
```{r}
ggplot() + 
  geom_density(aes(x = BAH$lap_time), fill="#69b3a2", color="#e9ecef") + 
  labs(x = "Lap Time", y = "Density", title = "Density Plot of Lap Times at Bahrain GP 2023") +
  theme(plot.title = element_text(hjust=0.5))
```


```{r }
ggplot() + geom_boxplot(aes(x = BAH$team, y = BAH$lap_time))+
  labs(x = "Team", y = "Lap Time", title = "Box Plot of Lap Time per Team (Bahrain 2023)") +
  theme_minimal() + theme(axis.text.x = element_text(angle = 45, hjust=1)) +
  theme(plot.title = element_text(hjust = 0.5))

```

Before pairplot we need to set the categorical variables as factors

```{r}
BAH$driver <- factor(BAH$driver)
BAH$team <- factor(BAH$team)
BAH$tyre <- factor(BAH$tyre) 

# Circuit characteristics
BAH$traction <- factor(BAH$traction, ordered = TRUE)
BAH$asphalt_grip <- factor(BAH$asphalt_grip, ordered = TRUE)
BAH$asphalt_abrasion <- factor(BAH$asphalt_abrasion, ordered = TRUE)
BAH$track_evol <- factor(BAH$track_evol, ordered = TRUE)
BAH$tyre_stress <- factor(BAH$tyre_stress, ordered = TRUE)
BAH$braking <- factor(BAH$braking, ordered = TRUE)
BAH$lateral <- factor(BAH$lateral, ordered = TRUE)
BAH$downforce <- factor(BAH$downforce, ordered = TRUE)

```


```{r pairplot}
ggpairs(BAH, columns = c("lap_time", "team", "position", "pitstop_duration"))
```

```{r pistop density}
ggplot() + 
  geom_density(aes(x = BAH$pitstop_duration), fill="#ec8ccd", color="#ec8ccd") + 
  labs(x = "Pitstop Duration", y = "Density", title = "Density Plot of Pitstop Duration at Bahrain GP 2023") +
  theme(plot.title = element_text(hjust=0.5))
```

```{r pitstop binning}
BAH$pitstop_duration <- as.numeric(BAH$pitstop_duration)

BAH$pitstop_duration <- cut(BAH$pitstop_duration, breaks = c(min(BAH$pitstop_duration, na.rm = TRUE), quantile(BAH$pitstop_duration, probs = c(.2, .4,  .6, .8),na.rm=TRUE),max(BAH$pitstop_duration, na.rm = TRUE)), ordered_result = TRUE, include.lowest = TRUE)

```


```{r clean and order data}
BAH$driver <- factor(BAH$driver)
BAH$team <- factor(BAH$team)

# Circuit characteristics
BAH$traction <- factor(BAH$traction, ordered = TRUE)
BAH$asphalt_grip <- factor(BAH$asphalt_grip, ordered = TRUE)
BAH$asphalt_abrasion <- factor(BAH$asphalt_abrasion, ordered = TRUE)
BAH$track_evol <- factor(BAH$track_evol, ordered = TRUE)
BAH$tyre_stress <- factor(BAH$tyre_stress, ordered = TRUE)
BAH$braking <- factor(BAH$braking, ordered = TRUE)
BAH$lateral <- factor(BAH$lateral, ordered = TRUE)
BAH$downforce <- factor(BAH$downforce, ordered = TRUE)

# Lap time - ordered: the shorter the better
# the fastest lap is included thanks to argument include.lowest = TRUE
BAH$lap_time <- cut(BAH$lap_time, breaks = c(min(BAH$lap_time, na.rm = TRUE), quantile(BAH$lap_time,probs = c(.02, .05, .1, .15, .2, .3,.4,.5,.6, .7,.8, .85, .9, .95, .98),na.rm=TRUE),max(BAH$lap_time, na.rm = TRUE)), include.lowest = TRUE, ordered_result = TRUE)

# Add "no_pitstop" to the factor levels for pitstop_duration
BAH$pitstop_duration <- factor(BAH$pitstop_duration, 
                                levels = c("no_pitstop", levels(BAH$pitstop_duration)))
# Replace all NA values with "no_pitstop"
BAH <- BAH %>% replace_na(list(pitstop_duration = "no_pitstop"))


BAH$tyre <- factor(BAH$tyre)
BAH$rainfall <- factor(BAH$rainfall, ordered = TRUE)

# Make a variable for position on previous lap
BAH <- BAH %>%
  mutate(previous_position = ifelse(lap_number == 1, start_position, shift(BAH$position, n=1, type="lag")))

# Positions are ordered
BAH$previous_position <- factor(BAH$previous_position, ordered = TRUE)
BAH$position <- factor(BAH$position, ordered = TRUE)


```

```{r}
levels(BAH$pitstop_duration)
```


```{r}
ggplot() + geom_bar(aes(x = BAH$lap_time))+
  labs(x = "Lap Time Intervals", y = "Count", title="Lap Time Binning Results for Bahrain GP 2023")+
theme(axis.text.x = element_text(angle = 45, hjust=1), plot.title = element_text(hjust=0.5))
```



```{r}
count_LTPT <- BAH %>%
  filter(pitstop_duration != "no_pitstop") %>%
  count(pitstop_duration, lap_time) %>%
  spread(lap_time, n, fill = 0)

heatmap_data <- gather(count_LTPT, key = "lap_time", value = "count", -pitstop_duration)

ggplot(heatmap_data, aes(x = lap_time, y = pitstop_duration, fill = count)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "blue") +
  labs(title = "Distribution of Pitstop Duration vs Lap Time",
       x = "Lap Time",
       y = "Pitstop Duration",
       fill = "Count") +
  theme_minimal() +
  theme(plot.title = element_text(hjust=0.5))

```
```{r checking NAs}
# check which rows have NAs and investigate why
which(is.na(BAH))
```
```{r deal with NAs}
# dropping  nas
BAH <- drop_na(BAH)

```


```{r pitlane start warning}
# if starting position is 0, raise a Warning to check if that was a pitlane start
BAH %>%
  group_by(team) %>%
  summarize(has_zero = any(previous_position == 0), .groups = "drop") %>%
  filter(has_zero) %>%
  pull(team) -> drivers_with_zero

# Raise warning if any drivers seem to be starting from pitlane - check with reports on F1 website
if (length(drivers_with_zero) > 0) {
  warning(paste("The following drivers have starting position = 0:", paste(drivers_with_zero, collapse = ", ")))
}
```

# Simple DAG
## Known DAG.

Suppose we want to model the Bahrain GP with 5 variables: lap time, tyre compound, team, position, pitstop duration.


```{r}
library(bnlearn)
library(Rgraphviz)

# Choosing relevant variables
BAH1 <- BAH %>%  dplyr::select(c(lap_time, 
                                  tyre, team, position,
                                pitstop_duration)) 

dag = empty.graph(nodes = c("lap_time", "tyre", "team", "position", "pitstop_duration"))
# Known relationships
arc.set = matrix(c("team", "position",
                   "team", "tyre",
                   "lap_time", "position",
                   "tyre", "lap_time",
                  "pitstop_duration", "lap_time",
                   "pitstop_duration", "position",
                  "team", "pitstop_duration"), 
                 byrow = TRUE, ncol=2, dimnames =list(NULL,c("from","to")))
arcs(dag) = arc.set
graphviz.plot(dag)
```
```{r}
arc.strength(dag, data = BAH1, criterion = "x2")
```


```{r}
bn.bayes = bn.fit(dag,data=BAH1, method = "bayes", iss = 10)

bn.bayes$pitstop_duration
```

```{r}
bn.fit.barchart(bn.bayes$lap_time)
```

```{r}
bn.fit.barchart(bn.bayes$tyre)
```

```{r}
graphviz.chart(bn.bayes)
```

```{r}
bn.bayes$lap_time
```

```{r}
bn.bayes$tyre
```
## DAG unknown: constraint-based method (incremental association Markov blanket)

```{r}
BAH.iamb =iamb(BAH1, test ='mi')
graphviz.plot(BAH.iamb)
```

```{r}
bl = matrix(c("tyre", "team"), 
            ncol = 2, byrow = TRUE)
```


```{r}
BAH.iamb_bl =iamb(BAH1, blacklist = bl, test ='mi')
graphviz.plot(BAH.iamb_bl)
```


### Perform independence tests



```{r}
# Does pistop influence lap time?
ci.test("lap_time","pitstop_duration", test = "jt", data = BAH1)
```
```{r}
# Does team influence position?
ci.test("position", "team", test = "mc-mi", data = BAH1)
```

```{r}
# Does team influence pitstop?
ci.test("pitstop_duration", "team", test = "mc-mi", data = BAH1)
```


```{r}
# Add the arcs from conditional independence tests with resulting p-value < 0.05
new_BAH.iamb_bl = set.arc(BAH.iamb_bl, from = "pitstop_duration", to = "lap_time")
new_BAH.iamb_bl = set.arc(new_BAH.iamb_bl, from = "team", to = "position")
new_BAH.iamb_bl = set.arc(new_BAH.iamb_bl, from = "team", to = "pitstop_duration")


graphviz.plot(new_BAH.iamb_bl)
```
```{r}
# Does pitstop influence position?
ci.test("position", "pitstop_duration", "team", test = "mc-mi", data = BAH1)
```

```{r}
new_BAH.iamb_bl = set.arc(new_BAH.iamb_bl, from = "pitstop_duration", to = "position")

graphviz.plot(new_BAH.iamb_bl)
```



```{r}
# Does tyre influence lap time?
ci.test("lap_time","tyre", c("pitstop_duration"), test = "mc-mi", data = BAH1)
```



```{r}
new_BAH.iamb_bl = set.arc(new_BAH.iamb_bl, from = "tyre", to = "lap_time")
graphviz.plot(new_BAH.iamb_bl)
```

```{r}
# Does lap time influence position?
ci.test("position","lap_time", c("tyre", "pitstop_duration"), test = "mc-mi", data = BAH1)
```

```{r}
new_BAH.iamb_bl = set.arc(new_BAH.iamb_bl, from = "lap_time", to = "position")
graphviz.plot(new_BAH.iamb_bl)
```

```{r}
# Does tyre influence pitstop?
ci.test("pitstop_duration","tyre", "team", test = "mc-mi", data = BAH1)
```

```{r}
# Does pitstop influence tyre?
ci.test("tyre", "pitstop_duration", "team", test = "mc-mi", data = BAH1)
```
```{r}
# Does tyre influence position?
ci.test("position", "tyre", c("lap_time", "team", "pitstop_duration"), test = "mc-mi", data = BAH1)
```

```{r}
new_BAH.iamb_bl = set.arc(new_BAH.iamb_bl, from = "tyre", to = "position")
graphviz.plot(new_BAH.iamb_bl)
```

## DAG uknown: score-based method (hill-climbing)

```{r}
# Use hill-climbing to determine the DAG
BAH.hc1 =hc(BAH1)
graphviz.plot(BAH.hc1)
```

Learning DAG using hill climbing and whitelists, blacklists


```{r}
# Use hill-climbing to determine the DAG with blacklisting
BAH.hc_bl =hc(BAH1, blacklist = bl)
graphviz.plot(BAH.hc_bl)
```
```{r}
arc.strength(BAH.hc_bl, data = BAH1, criterion = "x2")
```


```{r}
wl = matrix(c("lap_time", "position"), 
            ncol = 2, byrow = TRUE)
```

There is a lot of blacklisting/ whitelisting involved, which pretty much determines the DAG - is this an indication it's better to use a known DAG with distributions of variables?

```{r}
# Use hill-climbing to determine the DAG
BAH.hc_bl_wl =hc(BAH1, blacklist = bl, whitelist = wl)
graphviz.plot(BAH.hc_bl_wl)
```

```{r}
# Nothing to team
for (name in names(BAH1)){
  bl4 = matrix(c(name, "team"), ncol=2, 
            dimnames =list(NULL,c("from","to")))
  bl = rbind(bl, bl4)
}
```

```{r}
# Use hill-climbing to determine the DAG
BAH.hc_bl_wl =hc(BAH1, blacklist = bl, whitelist = wl)
graphviz.plot(BAH.hc_bl_wl)
```

```{r}
arc.strength(BAH.hc_bl_wl, data = BAH1, criterion = "x2")
```
### Scores
```{r}
# Known
score(dag, data = BAH1, type = "bic")
score(BAH.hc1, data = BAH1, type = "bic")

# IAMB 
score(new_BAH.iamb_bl, data = BAH1, type = "bic")

# HC
score(BAH.hc_bl, data = BAH1, type = "bic")
score(BAH.hc_bl_wl, data = BAH1, type = "bic")

```

Here we can note that the CPDAG underlying hc and hc_bl is the same, so their dags are score-equivalent. Indeed, we get the same BIC score for both.

# Dynamic DAG
## Known DAG.

Suppose we want to model the Bahrain GP with 5 variables: lap time, tyre compound, team, position, pitstop duration.


```{r}
library(bnlearn)
library(Rgraphviz)

# Choosing relevant variables
BAH2 <- BAH %>%  dplyr::select(c(lap_time, 
                                  tyre, team, position,
                                pitstop_duration, previous_position)) 

dag = empty.graph(nodes = c("lap_time", "tyre", "team", "position", "pitstop_duration", "previous_position"))
arc.set = matrix(c("team", "position",
                   "team", "tyre",
                   "lap_time", "position",
                   "tyre", "lap_time",
                  "pitstop_duration", "lap_time",
                   "pitstop_duration", "position",
                  "team", "pitstop_duration",
                  "previous_position", "position"), 
                 byrow = TRUE, ncol=2, dimnames =list(NULL,c("from","to")))
arcs(dag) = arc.set
graphviz.plot(dag)
```
```{r}
arc.strength(dag, data = BAH2, criterion = "x2")
```


```{r}
bn.bayes = bn.fit(dag,data=BAH2, method = "bayes", iss = 10)

bn.bayes$pitstop_duration
```


```{r}
bn.bayes$tyre
```
## DAG uknown : score-based method

```{r}
# Use hill-climbing to determine the DAG
BAH.hc2 =hc(BAH2)
graphviz.plot(BAH.hc2)
```

Learning DAG using hill climbing and whitelists, blacklists

```{r}
# Blacklist variables so that chronological order is kept
bl = matrix(c(
  "position", "previous_position",
              "pitstop_duration", "tyre",
              "tyre", "pitstop_duration",
              "lap_time", "tyre"
              
              ), 
            ncol = 2, byrow = TRUE)

# Nothing from position
for (name in names(BAH2)){
  bl2 = matrix(c("position", name), ncol=2,
            dimnames =list(NULL,c("from","to")))
  bl = rbind(bl, bl2)
}


# Nothing to team
for (name in names(BAH2)){
  bl4 = matrix(c(name, "team"), ncol=2, 
            dimnames =list(NULL,c("from","to")))
  bl = rbind(bl, bl4)
}


# Nothing to previous position apart from team
for (name in names(BAH2)){
  if (name != "team"){
  bl3 = matrix(c(name, "previous_position"), ncol=2,
            dimnames =list(NULL,c("from","to")))
  bl = rbind(bl, bl3)}
}

bl
```



```{r}
# unknown_dag = empty.graph(nodes = names(BAH))
wl = matrix(c("previous_position", "position"
              # "lap_time", "position"
              ), 
            ncol = 2, byrow = TRUE)
```



```{r}
# Use hill-climbing to determine the DAG
BAH.hc2_bl_wl =hc(BAH2, blacklist = bl, whitelist = wl)
graphviz.plot(BAH.hc2_bl_wl)
```

```{r}
arc.strength(BAH.hc2_bl_wl, data = BAH2, criterion = "x2")
```

### Scores
```{r}
score(dag, data = BAH2, type = "bic")
score(BAH.hc2, data = BAH2, type = "bic")
score(BAH.hc2_bl_wl, data = BAH2, type = "bic")
```


## DAG unknown - constraint-based method (incremental association Markov blanket)

```{r}
BAH.iamb =iamb(BAH2, test ='mi')
graphviz.plot(BAH.iamb)
```

```{r}
BAH.iamb_bl =iamb(BAH2, blacklist = bl, test ='mi')
graphviz.plot(BAH.iamb_bl)
```
```{r}
BAH.iamb_bl_wl =iamb(BAH2, blacklist = bl, whitelist = wl, test ='mi')
graphviz.plot(BAH.iamb_bl_wl)
```

### Perform independence tests

```{r}
# Testing for conditional independence: position
ci.test("team", "previous_position", test = "mi", data = BAH2)
```
```{r}
dag.BAH = set.arc(BAH.iamb, from = "team", to = "previous_position")

ci.test("team", "pitstop_duration", test = "mi", data = BAH2)
```
```{r}
ci.test("lap_time","pitstop_duration", test = "jt", data = BAH2)
```

```{r}
ci.test("lap_time", "team", "tyre", test = "mi", data = BAH2)
```

```{r}
dag.BAH = set.arc(dag.BAH, from = "team", to = "lap_time")
dag.BAH = set.arc(dag.BAH, from = "pitstop_duration", to = "lap_time")
graphviz.plot(dag.BAH)
```
```{r}
ci.test("position", "pitstop_duration", c("lap_time", "previous_position"), test = "mc-jt", data = BAH2)
```
```{r}
dag.BAH = set.arc(dag.BAH, from = "pitstop_duration", to = "position")
ci.test("pitstop_duration", "previous_position", test = "mc-jt", data = BAH2)
```
```{r}
ci.test("position", "team", c("lap_time", "previous_position"), test = "mi", data = BAH2)
```

```{r}
graphviz.plot(dag.BAH)
```




```{r}
BAH.fit = bn.fit(dag.BAH, data = BAH2, method = "bayes", iss = 10)
```

```{r}
# We will need the gRain package
library(gRain)
# Use the gRain package to set evidence (condition on an event)
junction = compile(as.grain(BAH.fit))
```

```{r}
jf = setEvidence(junction, names(BAH)[!is.na(BAH[2,])],
                 as.vector(apply(BAH[2,!is.na(BAH[2,])],2,paste)))

graphviz.chart(BAH.fit, grid = TRUE, main = "Original BN")
```

